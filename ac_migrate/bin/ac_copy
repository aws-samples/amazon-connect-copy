#!/bin/bash

############################################################
#
# Copy Amazon Connect instance A to instance B safely
#

USAGE=$(cat <<EOD
Usage: $(basename $0) [-?de] helper
    Copy Amazon Connect instance A to instance B safely, based on the
    connect_list and connect_diff results, under the helper directory
    creating new components in helper.new, updating old components in helper.old,
    and updating references defined in helper.sed.

    helper        Name of the helper directory
    -d            Dry run - Run through the script but not updating the target instance
    -e            Proceed even when the Bash shell may not encode Extended ASCII characters properly
    -?            Help
EOD
)
usage() { echo -e "$USAGE" >&2; exit 2; }

error() {
    if [[ ! "$1" =~ ^[[:digit:]]+$ ]]; then
        # Not an AWS CLI error
        cat <<EOD >&2
Error: $*
EOD
    else
        # An AWS CLI error
        line_no=$1
        shift
        cat <<EOD >&2
$*
Error at line ${line_no}. Recommended actions:
Make sure all required prompts exist in the target instance, and
Install the latest AWS CLI: https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html .
EOD
    fi
    exit 1
}

hex_code() { printf '%s' "$1" | xxd -u -p -c1 | while read x; do printf "%%%s" "$x"; done }

path_encode()  {
    old_lc_collate=$LC_COLLATE
    LC_COLLATE=C
    local length="${#1}"
    for (( i = 0; i < length; i++ )); do
        local c="${1:$i:1}"
        case $c in
            [a-zA-Z0-9.~_-]) printf '%s' "$c";;
            *) x=$(hex_code "$c"); echo -n ${x//%0D/};;
        esac
    done
    LC_COLLATE=$old_lc_collate
}

path_decode() {
    local path_encoded="${1//+/ }"
    printf '%b' "${path_encoded//%/\\x}"
}

diff_files() {
    # Compare TEMPA (sedded and sorted into TEMPFILE) and TEMPB (sorted inline).
    # If same, return 0. If different, show the difference unsorted,
    # then ask if want to update. Return 1 if needs update and 0 otherwise.
    sed -f "$helper_sed" $TEMPA | tee $TEMPA2 | sort > $TEMPA3
    sort $TEMPB | diff -qbB - $TEMPA3 &> /dev/null
    if [ $? -eq 0 ]; then
        echo "same"
    else
        # sdiff $TEMPB $TEMPA2
        echo "need to update"
    fi
}

aws_connect() {
    local cmd=""
    local ii
    for ii; do
        [[ "$ii" =~ " " || "$ii" =~ "(" || "$ii" =~ ")" ]] && cmd="$cmd \"$ii\"" || cmd="$cmd $ii"
    done
    echo "aws connect$profile_flag$cmd" >> "$aws_cli_log"
    eval "aws connect$profile_flag$cmd" 2> $TEMPERR
    local ret=$?
    if [ -s $TEMPERR ]; then
        cat $TEMPERR | tee -a "$aws_cli_log" >&2
    fi
    return $ret
}

## Max Queue Configs in a routing profile cannot be greater than 10
MaxQC=10
## Max contacts in a queue defaults to 2610 in certain cases. This can cause an error while updating queue
MaxContacts=2610

TEMPFILE=$(mktemp)
TEMPERR=${TEMPFILE}_err
TEMPNEW=${TEMPFILE}_new
TEMPOLD=${TEMPFILE}_old
TEMPA=${TEMPFILE}_A
TEMPB=${TEMPFILE}_B
TEMPA2=${TEMPFILE}_A2
TEMPA3=${TEMPFILE}_A3
TEMPA4=${TEMPFILE}_A4
trap 'rm -r -- $TEMPFILE $TEMPERR $TEMPNEW $TEMPOLD $TEMPA $TEMPB $TEMPA2 $TEMPA3 $TEMPA4' EXIT
touch $TEMPFILE $TEMPERR $TEMPNEW $TEMPOLD $TEMPA $TEMPB $TEMPA2 $TEMPA3 $TEMPA4

## Set directories
homedir=`pwd`
rscdir="${homedir}/resources"

## Added flow exception file to skip flows that cannot be migrated. e.g. Can contain caller-id setting of claimed number from source account
## e.g. lambda src-function-name dest-function-name
flowExceptions="${rscdir}/flowExceptions"

actionLead="# Action -"
dryrun=
ignore_improper_extended_ascii=
while getopts "?de" arg; do
    case "$arg" in
    d)  dryrun=on; echo "Dry Run";;
    e)  ignore_improper_extended_ascii=on;;
    *)  usage;;
    esac
done
shift $((OPTIND-1))

if [ "$(hex_code "é")" != "%C3%A9" ]; then
    echo "WARNING: This Bash shell may not encode Extended ASCII characters properly." >&2
    if [ -n "$ignore_improper_extended_ascii" ]; then
        echo "Proceed regardless as the -e option is specified." >&2
    else
        cat <<EOD >&2

If your instance component names contain Extended ASCII characters, such as accented letters
like é, this Bash shell will encode those names differently from standard Bash shell encoding.

If you are sure that your component names do not contain Extended ASCII characters,
you may proceed regardless by running the command again with the -e option.
EOD
        exit 1
    fi
fi

helper=$1

if [ -z "$helper" ]; then
    usage
fi

for ext in var sed new old del skip; do
    eval helper_$ext="$helper/helper.$ext"
done

if [ ! -s "$helper_var" ]; then
    error "\"$helper_var\" does not exist. \"$helper\" is probably not a Helper directory."
fi

. "$helper_var"
profile=$aws_profile_b
profile_flag=${profile:+ --profile $profile}
account_b=$aws_ac_b

cat <<EOD
Instance Alias A: $instance_alias_a (in directory "$instance_alias_dir_a")
Instance Alias B: $instance_alias_b (in directory "$instance_alias_dir_b")
Helper Directory: $helper
AWS Profile B in use: ${profile:-${AWS_PROFILE:-(default)}}
Context Flow Prefix: $contact_flow_prefix
EOD

contact_flow_prefix_encoded=$(path_encode "$contact_flow_prefix")
contact_flow_prefix_text="${contact_flow_prefix:+ with names prefixed with \"$contact_flow_prefix\"}"

helper_older_than=

if [ "$helper_var" -ot "$instance_alias_dir_a/instance.var" ]; then
    helper_older_than="$helper_older_than $instance_alias_a"
fi

if [ "$helper_var" -ot "$instance_alias_dir_b/instance.var" ]; then
    helper_older_than="$helper_older_than $instance_alias_b"
fi

if [ -n "$helper_older_than" ]; then
    echo
    error "Instances$helper_older_than updated since helper \"$helper\" was created. Please run connect_diff again."
fi

helper_log="${helper%/}.log"
aws_cli_log="$helper_log"
cat <<EOD > "$helper_log"
# This log file is for AWS CLI tracing, not for direct execution.
# Please use the $(basename $0) command (in non-dry-run mode) to perform the copying instead.
#
EOD

if [ -n "$dryrun" ]; then
    cat <<EOD >> "$helper_log"
# Dry-run mode - Actions listed below are not being carried out
#
EOD
fi

if [ -z "$dryrun" ]; then
   read -p "Do you want to start migration from source instance ("$instance_alias_a") to destination instance ("$instance_alias_b") (yes/no): "    ans
   if [ "$ans" != "yes" ]; then
        echo "Exiting migration..."
        exit 0
   fi
fi
############################################################
## Creating list of newly created resources that can be deleted from instance B
	echo "## Newly created resources in instance B that can be removed (except queues, routingprofiles and hours of operation)" > $helper_del
	echo "instance_${instance_alias_dir_b}|$instance_id_b" >> $helper_del

## Skipped modules and flows due to hard-coded caller Id settings
	echo "instance_${instance_alias_dir_b}|$instance_id_b" > $helper_skip

############################################################
#
# Prompts
#

cat <<EOD

Prompts
-------
EOD

egrep -q "^prompt_" "$helper_new"
if [ $? -eq 1 ]; then
    echo "All prompts in the source instance exist in the target instance."
else
    echo "These prompts are found in the source instance but do not exist in the target instance."
    echo "Manual upload required:"
    egrep "^prompt_" "$helper_new" | sort | sed -e's/_/: /'
fi


############################################################
#
# Hours of operations
#

cat <<EOD

Hours of operations
-------------------
EOD
# Preload as $helper_old may change
egrep "^hour_" "$helper_old" > $TEMPOLD
# Create what is in $helper_new
egrep "^hour_" "$helper_new" > $TEMPNEW
if [ ! -s $TEMPNEW ]; then
    echo "No hours of operations to create"
else
    num_hours=$(echo $(cat $TEMPNEW | wc -l))
    echo -e "\nCreating $num_hours Hours of operations"
    ii=0
    sort $TEMPNEW |
    while read hour_json; do
        ii=$[ii+1]
        echo "$ii. $hour_json"
        hour_name=${hour_json#hour_}
        hour_name=${hour_name%.json}
        hour_name_decoded=$(path_decode "$hour_name")
	h_desc_new=$hour_name_decoded

        hour_id_a=$(jq -r ".HoursOfOperation.HoursOfOperationId" "$instance_alias_dir_a/$hour_json")

################
	## Lets make sure description is not null
	hour_desc=$(jq -r ".HoursOfOperation.Description" "$instance_alias_dir_a/$hour_json")

	## if description does not exist then set to same as name
	if [ "$hour_desc" = "null" -o "$hour_desc" = "" ]; then
		## There is no description for hours - set it to default
                cat "$instance_alias_dir_a/$hour_json" | jq --arg hour_desc_new "$h_desc_new" \
                        ".HoursOfOperation | del(.Description) | . + { Description: \$hour_desc_new}" > "$TEMPA"
	        cat "$TEMPA" |
        		jq --arg iid $instance_id_b \
          	  	"del(.HoursOfOperationId, .HoursOfOperationArn) | . + { InstanceId: \$iid}" |
            		sed -f "$helper_sed" > "$helper/$hour_json"

	else
		## Hours description exists
	        cat "$instance_alias_dir_a/$hour_json" |
	        	jq --arg iid $instance_id_b \
    	       		 ".HoursOfOperation | del(.HoursOfOperationId, .HoursOfOperationArn) | . + { InstanceId: \$iid}" |
            		sed -f "$helper_sed" > "$helper/$hour_json"

	fi

        cat <<EOD >> "$helper_log"

$actionLead Create hours of operation: $hour_name_decoded
EOD
        if [ -n "$dryrun" ]; then
            cat <<EOD
Dry-create hours of operation
$(cat "$helper/$hour_json")

EOD
            cat <<EOD >> "$helper_log"
aws connect create-hours-of-operation \
--cli-input-json "file://$helper/$hour_json" \
> "$helper/output_$hour_json"
EOD
            # rm "$helper/$hour_json"
            continue
        fi

        aws_connect create-hours-of-operation \
            --cli-input-json "file://$helper/$hour_json" \
            > "$helper/output_$hour_json" || error $LINENO
        hour_id_b=$(jq -r ".HoursOfOperationId" "$helper/output_$hour_json")

        aws_connect describe-hours-of-operation \
            --instance-id $instance_id_b \
            --hours-of-operation-id $hour_id_b \
            > "$instance_alias_dir_b/$hour_json" || error $LINENO

## Creating list of newly created resources that can be deleted from instance B
	echo "hour_${hour_name_decoded}|$hour_id_b" >> $helper_del
##
        # Moving hour_json from helper_new to helper_old
        echo $hour_json >> "$helper_old"
        sed -e"/$hour_json/d" "$helper_new" > $TEMPFILE
        cat $TEMPFILE > "$helper_new"

        cat <<EOD >> "$helper_sed"
# Hour of operation: $hour_name_decoded
s%$hour_id_a%$hour_id_b%g
EOD
    done
    test $? -eq 0 || error

    if [ -z "$dryrun" ]; then
        # Update instance B hours
        aws_connect list-hours-of-operations \
            --instance-id $instance_id_b \
            > $TEMPFILE || error $LINENO
        cat $TEMPFILE |
        jq -r ".HoursOfOperationSummaryList[]" > "$instance_alias_dir_b/hours.json"
    fi
fi

if [ ! -s $TEMPOLD ]; then
    echo "No hours of operations to update"
else
    num_hours=$(echo $(cat $TEMPOLD | wc -l))
    echo -e "\nChecking $num_hours hours of operations for an update"
    ii=0
    sort $TEMPOLD |
    while read hour_json; do
        ii=$[ii+1]
        echo -n "$ii. $hour_json ... "
        hour_name=${hour_json#hour_}
        hour_name=${hour_name%.json}
        hour_name_decoded=$(path_decode "$hour_name")
        cat "$instance_alias_dir_a/$hour_json" > $TEMPA
        cat "$instance_alias_dir_b/$hour_json" > $TEMPB
        df=$(diff_files); echo $df; test "$df" == "same" && continue
        echo "Updating $hour_json"

        hour_id_b=$(jq -r ".HoursOfOperation.HoursOfOperationId" "$instance_alias_dir_b/$hour_json")
        arg_flags=$(cat "$instance_alias_dir_b/$hour_json" |
            jq -r ".HoursOfOperation | \"--arg id \" + .HoursOfOperationId")
        cat "$instance_alias_dir_a/$hour_json" |
        jq --arg iid $instance_id_b $arg_flags \
            ".HoursOfOperation | del(.HoursOfOperationArn, .Tags) | . + { InstanceId: \$iid, HoursOfOperationId: \$id }" \
            > "$helper/$hour_json"

        cat <<EOD >> "$helper_log"

$actionLead Update hours of operation: $hour_name_decoded
EOD
        if [ -n "$dryrun" ]; then
            cat <<EOD
Dry-update hours of operation
$(cat "$helper/$hour_json")

EOD
            cat <<EOD >> "$helper_log"
aws connect update-hours-of-operation \
--cli-input-json "file://$helper/$hour_json" \
> "$helper/output_$hour_json"
EOD
            # rm "$helper/$hour_json"
            continue
        fi

        aws_connect update-hours-of-operation \
            --cli-input-json "file://$helper/$hour_json" \
            > "$helper/output_$hour_json" || error $LINENO

        aws_connect describe-hours-of-operation \
            --instance-id $instance_id_b \
            --hours-of-operation-id $hour_id_b \
            > "$instance_alias_dir_b/$hour_json" || error $LINENO
    done
    test $? -eq 0 || error
fi


############################################################
#
# Queues
#

cat <<EOD

Queues
------
EOD
# Preload as $helper_old may change
egrep "^queue_" "$helper_old" > $TEMPOLD
# Create what is in $helper_new
egrep "^queue_" "$helper_new" > $TEMPNEW
if [ ! -s $TEMPNEW ]; then
    echo "No queues to create"
else
    num_queues=$(echo $(cat $TEMPNEW | wc -l))
    echo -e "\nCreating $num_queues queues"
    ii=0
    sort $TEMPNEW |
    while read queue_json; do
        ii=$[ii+1]
        echo "$ii. $queue_json"
        queue_name=${queue_json#queue_}
        queue_name=${queue_name%.json}
        queue_name_decoded=$(path_decode "$queue_name")
	q_desc_new=$queue_name_decoded

        queue_id_a=$(jq -r ".Queue.QueueId" "$instance_alias_dir_a/$queue_json")

################
	## Lets make sure queue description is not null and max contacts not equal to MaxContacts
	queue_desc=$(jq -r ".Queue.Description" "$instance_alias_dir_a/$queue_json")
	max_contacts=$(jq -r ".Queue.MaxContacts" "$instance_alias_dir_a/$queue_json")
	if [ $max_contacts = null ]; then
		max_contacts=0
	fi

	## Let's set flags to determine what need to be updated
	maxc=no	# No need to update max contacts
	qdesc=yes # Queue description exists
	# Max contacts in a queue cannot be MaxContacts
        if [ $max_contacts -eq $MaxContacts ]; then
		maxc=yes
	fi
	if [ "$queue_desc" = "null" -o "$queue_desc" = "" ]; then
		qdesc=no
	fi

	# Now lets check and update as appropriate
        if [ "$maxc" = "no" -a "$qdesc" = "yes" ]; then
                ## Max contacts in a queue is good and queue description exist
	        cat "$instance_alias_dir_a/$queue_json" |
        		jq --arg instance_id $instance_id_b \
           		 ".Queue | del(.QueueId, .QueueArn, .OutboundCallerConfig, .Status) | . + { InstanceId: \$instance_id}" |
       		 sed -f "$helper_sed" > "$helper/$queue_json"
	elif [ "$maxc" = "no" -a "$qdesc" = "no" ]; then
		## Max contacts in a queue is good but queue description does not exist
                ## Set queue description to same as queue name
                cat "$instance_alias_dir_a/$queue_json" | jq --arg queue_desc_new "$q_desc_new" \
                        ".Queue | del(.Description) | . + { Description: \$queue_desc_new}" > "$TEMPA"
                cat "$TEMPA" | jq --arg instance_id $instance_id_b \
                        "del(.QueueId, .QueueArn, .OutboundCallerConfig, .Status) | . + { InstanceId: \$instance_id}" |
      	 		 sed -f "$helper_sed" > "$helper/$queue_json"
	elif [ "$maxc" = "yes" -a "$qdesc" = "yes" ]; then
                ## Max contacts in a queue is NOT good and queue description exist
		## Remove Max contacts
	        cat "$instance_alias_dir_a/$queue_json" |
        		jq --arg instance_id $instance_id_b \
           		 ".Queue | del(.QueueId, .QueueArn, .OutboundCallerConfig, .Status, .MaxContacts) | . + { InstanceId: \$instance_id}" |
       		 sed -f "$helper_sed" > "$helper/$queue_json"
	else
		## Max contacts in a queue is NOT good and queue description does not exist
		## Remove Max contacts and Set queue description to same as queue name
                cat "$instance_alias_dir_a/$queue_json" | jq --arg queue_desc_new "$q_desc_new" \
                        ".Queue | del(.Description) | . + { Description: \$queue_desc_new}" > "$TEMPA"
                cat "$TEMPA" | jq --arg instance_id $instance_id_b \
                        "del(.QueueId, .QueueArn, .OutboundCallerConfig, .Status, .MaxContacts) | . + { InstanceId: \$instance_id}" |
      	 		 sed -f "$helper_sed" > "$helper/$queue_json"
        fi
################

        cat <<EOD >> "$helper_log"

$actionLead Create queue: $queue_name_decoded
EOD
        if [ -n "$dryrun" ]; then
            cat <<EOD
Dry-create queue
$(cat "$helper/$queue_json")

EOD
            cat <<EOD >> "$helper_log"
aws connect create-queue \
--cli-input-json "file://$helper/$queue_json" \
> "$helper/output_$queue_json"
EOD
            # rm "$helper/$queue_json"
            continue
        fi

        aws_connect create-queue \
            --cli-input-json "file://$helper/$queue_json" \
            > "$helper/output_$queue_json" || error $LINENO
        queue_id_b=$(jq -r ".QueueId" "$helper/output_$queue_json")

        aws_connect describe-queue \
            --instance-id $instance_id_b \
            --queue-id $queue_id_b \
            > "$instance_alias_dir_b/$queue_json" || error $LINENO

	## There will not be any quick-connects associated with the newly created queue. Create an empty file for later comparison
## 	aws_connect list-queue-quick-connects \
##        	--instance-id $instance_id_b \
##        	--queue-id $queue_id_b \
##        	> "$instance_alias_dir_b/queue_qc_$queue_name_decoded.json" || error $LINENO

	echo '{
    "QuickConnectSummaryList": []
}'         	> "$instance_alias_dir_b/queue_qc_$queue_name.json"

## Creating list of newly created resources that can be deleted from instance B
	echo "queue_${queue_name_decoded}|$queue_id_b" >> $helper_del
###############

        # Moving queue_json from helper_new to helper_old
        echo $queue_json >> "$helper_old"
        sed -e"/$queue_json/d" "$helper_new" > $TEMPFILE
        cat $TEMPFILE > "$helper_new"

        cat <<EOD >> "$helper_sed"
# Queue: $queue_name_decoded
s%$queue_id_a%$queue_id_b%g
EOD
    done
    test $? -eq 0 || error

    if [ -z "$dryrun" ]; then
        # Update instance B queues
        aws_connect list-queues \
            --instance-id $instance_id_b \
            > $TEMPFILE || error $LINENO
        cat $TEMPFILE |
        jq -r ".QueueSummaryList[] | select(.QueueType != \"AGENT\")" > "$instance_alias_dir_b/queues.json"
    fi
fi

## Load helper_old so that we can check if queues in destination instance need manual updates
## e.g. for outbound number configuration
egrep "^queue_" "$helper_old" > $TEMPOLD
if [ ! -s $TEMPOLD ]; then
    echo "No queues to update"
else
    num_queues=$(echo $(cat $TEMPOLD | wc -l))
    echo -e "\nChecking $num_queues queues for an update"
    ii=0
    sort $TEMPOLD |
    while read queue_json; do
        ii=$[ii+1]
        echo -n "$ii. $queue_json ... "
 #       cat "$instance_alias_dir_a/$queue_json" |
 #       jq "del(.Queue.OutboundCallerConfig)" > $TEMPA

	## We need to compare to make sure any outbound number configuration is also flagged, so leave it in (Commented above two lines)
        cat "$instance_alias_dir_a/$queue_json" > $TEMPA
        cat "$instance_alias_dir_b/$queue_json" > $TEMPB
        df=$(diff_files); echo $df; test "$df" == "same" && continue
        echo "Skipping this update. May contain outbound number configuration. Please update $queue_json manually considering potential operation impact."
## Lets record that we skipped this update
	echo "$queue_json|dummyId" >> $helper_skip
    done
fi


############################################################
#
# Routing Profiles
#

gen_helper_rpqr() {
    # Routing Profile Queue Reference
    routing_name=$1
    out_file="$helper/routingQRs_$routing_name.json"
## If queue config in a routing profile exceeds count of 10 then it cannot be updated
    rpqcnt=`cat "$instance_alias_dir_a/routingQs_$routing_name.json" |grep "QueueId" | wc -l`
    if [ $rpqcnt -gt $MaxQC ]; then
	## Queue configuration in routing profile exceeds maximum that can be used with API - take maximum (defined in variable MaxQC)
	k=0
	while [ $k -lt $MaxQC ]; do
        	cat "$instance_alias_dir_a/routingQs_$routing_name.json" |  jq ".RoutingProfileQueueConfigSummaryList[$k] | { QueueReference: { QueueId, Channel }, Priority, Delay }"  >> "$out_file"
         	k=`expr $k + 1`
	done
       echo "$out_file"
    else
       cat "$instance_alias_dir_a/routingQs_$routing_name.json" |
       jq ".RoutingProfileQueueConfigSummaryList[] |
           { QueueReference: { QueueId, Channel }, Priority, Delay }" \
       > "$out_file"
       echo "$out_file"
    fi
}

gen_helper_routing_new() {
    routing_name=$1
    out_file="$helper/routingNew_$routing_name.json"
    rpqr_file=$(gen_helper_rpqr "$routing_name")
    cat "$instance_alias_dir_a/routing_$routing_name.json" |
    jq --arg iid $instance_id_b \
        --slurpfile rpqc "$rpqr_file" \
        ".RoutingProfile |
        del(.RoutingProfileId, .RoutingProfileArn) |
        . + { InstanceId: \$iid, QueueConfigs: \$rpqc } |
        del(.MediaConcurrencies[] | select(.Concurrency == 0))" |
    sed -f "$helper_sed" > "$out_file"
    rm "$rpqr_file"
    echo "$out_file"
}

gen_helper_routing_old() {
    routing_name=$1
    out_file="$helper/routingOld_$routing_name.json"
    rpqr_file=$(gen_helper_rpqr "$routing_name")
    cat "$instance_alias_dir_b/routing_$routing_name.json" |
    jq --arg iid $instance_id_b \
        --slurpfile rpqc "$rpqr_file" \
        ".RoutingProfile |
        { InstanceId, RoutingProfileId, QueueConfigs: \$rpqc }" |
    sed -f "$helper_sed" > "$out_file"
    rm "$rpqr_file"
    echo "$out_file"
}

cat <<EOD

Routing Profiles
----------------
EOD
# Preload as $helper_old may change
egrep "^routing_" "$helper_old" > $TEMPOLD
# Create what is in $helper_new
egrep "^routing_" "$helper_new" > $TEMPNEW
if [ ! -s $TEMPNEW ]; then
    echo "No routing profiles to create"
else
    num_routings=$(echo $(cat $TEMPNEW | wc -l))
    echo -e "\nCreating $num_routings routing profiles"
    ii=0
    sort $TEMPNEW |
    while read routing_json; do
        ii=$[ii+1]
        echo "$ii. $routing_json"
        routing_name=${routing_json#routing_}
        routing_name=${routing_name%.json}
        routing_name_decoded=$(path_decode "$routing_name")

        routing_id_a=$(jq -r ".RoutingProfile.RoutingProfileId" "$instance_alias_dir_a/$routing_json")
        routing_new_file=$(gen_helper_routing_new "$routing_name")
        out_file="$helper/output_routing_new_$routing_name.json"

        cat <<EOD >> "$helper_log"

$actionLead Create routing profile: $routing_name_decoded
EOD
        if [ -n "$dryrun" ]; then
            cat <<EOD
Dry-create routing profile
$(cat "$routing_new_file")

EOD
            cat <<EOD >> "$helper_log"
aws connect create-routing-profile \
--cli-input-json "file://$routing_new_file" \
> "$out_file"
EOD
            # rm "$routing_new_file"
            continue
        fi

        aws_connect create-routing-profile \
            --cli-input-json "file://$routing_new_file" \
            > "$out_file" || error $LINENO
        routing_id_b=$(jq -r ".RoutingProfileId" "$out_file")

        # All routing profiles will be updated with queues
        echo "$routing_json" >> $TEMPOLD

        aws_connect describe-routing-profile \
            --instance-id $instance_id_b \
            --routing-profile-id $routing_id_b \
            > "$instance_alias_dir_b/$routing_json" || error $LINENO

        aws_connect list-routing-profile-queues \
            --instance-id $instance_id_b \
            --routing-profile-id $routing_id_b \
            > "$instance_alias_dir_b/routingQs_$routing_name.json" || error $LINENO

## Creating list of newly created resources that can be deleted from instance B
	echo "routing_${routing_name_decoded}|$routing_id_b" >> $helper_del
###############

        # Moving routing_json from helper_new to helper_old
        echo "$routing_json" >> "$helper_old"
        sed -e"/$routing_json/d" "$helper_new" > $TEMPFILE
        cat $TEMPFILE > "$helper_new"

        cat <<EOD >> "$helper_sed"
# Routing Profile: $routing_name_decoded
s%$routing_id_a%$routing_id_b%g
EOD
    done
    test $? -eq 0 || error

    if [ -z "$dryrun" ]; then
        # Update instance B routing profiles
        aws_connect list-routing-profiles \
            --instance-id $instance_id_b \
            > $TEMPFILE || error $LINENO
        cat $TEMPFILE |
        jq -r ".RoutingProfileSummaryList[]" > "$instance_alias_dir_b/routings.json"
    fi
fi

if [ ! -s $TEMPOLD ]; then
    echo "No routing profiles to update"
else
    num_routings=$(echo $(cat $TEMPOLD | wc -l))
    # echo $num_routings existing routing profiles: not to be auto-updated due to possible operation impact
    echo -e "\nChecking $num_routings routing profiles for an update"
    ii=0
    sort $TEMPOLD |
##### While reading routing json
    while read routing_json; do
        ii=$[ii+1]
        echo -n "$ii. $routing_json ... "
        routing_name=${routing_json#routing_}
        routing_name=${routing_name%.json}
        routing_name_decoded=$(path_decode "$routing_name")

        cat "$instance_alias_dir_a/$routing_json" |
        jq "del(.RoutingProfile.MediaConcurrencies[] | select(.Concurrency == 0))" > $TEMPA
        cat "$instance_alias_dir_b/$routing_json" |
        jq "del(.RoutingProfile.MediaConcurrencies[] | select(.Concurrency == 0))" > $TEMPB
        # df=$(diff_files); echo $df; test "$df" == "same" && continue
        df_r=$(diff_files)

        cat "$instance_alias_dir_a/routingQs_$routing_name.json" > $TEMPA
        cat "$instance_alias_dir_b/routingQs_$routing_name.json" > $TEMPB
        # df=$(diff_files); echo $df; test "$df" == "same" && continue
        df_rq=$(diff_files)

        if [ "$df_r" == "same" -a "$df_rq" == "same" ]; then
            echo same
            continue
        fi

        echo " routing $df_r routing-queues $df_rq"
        echo "Updating $routing_json"

        # routing_old_file=$(gen_helper_routing_old "$routing_name")
        routing_id_b=$(jq -r ".RoutingProfile.RoutingProfileId" "$instance_alias_dir_b/$routing_json")

        if [ "$df_r" != "same" ]; then
            # Update Routing Profile of Instance B ahead of time
            # then update the concurrency and default-outbound-queue.
            # (The name must have already matched.)
            if [ -z "$dryrun" ]; then
                cat "$instance_alias_dir_a/$routing_json" |
                sed -f "$helper_sed" > "$instance_alias_dir_b/$routing_json"
            fi

            routing_doq_b=$(cat "$instance_alias_dir_b/$routing_json" |
                jq -r ".RoutingProfile.DefaultOutboundQueueId")

            cat "$instance_alias_dir_b/$routing_json" |
            jq -r ".RoutingProfile.MediaConcurrencies[] | select(.Concurrency != 0)" |
            jq -s > "$helper/routingConcurrency_$routing_name.json"

            cat <<EOD >> "$helper_log"

$actionLead Update routing profile: $routing_name_decoded
EOD
            if [ -n "$dryrun" ]; then
                cat <<EOD
Dry-update routing profile default outbound queue to "$routing_doq_b"
Dry-update routing profile concurrency
$(cat "$helper/routingConcurrency_$routing_name.json")

EOD
                cat <<EOD >> "$helper_log"
aws connect update-routing-profile-default-outbound-queue \
--instance-id $instance_id_b \
--routing-profile-id $routing_id_b \
--default-outbound-queue-id $routing_doq_b
aws connect update-routing-profile-concurrency \
--instance-id $instance_id_b \
--routing-profile-id $routing_id_b \
--media-concurrencies "file://$helper/routingConcurrency_$routing_name.json"
EOD
                # rm "$helper/routingConcurrency_$routing_name.json"
            else
                aws_connect update-routing-profile-default-outbound-queue \
                    --instance-id $instance_id_b \
                    --routing-profile-id $routing_id_b \
                    --default-outbound-queue-id $routing_doq_b || error $LINENO

                aws_connect update-routing-profile-concurrency \
                    --instance-id $instance_id_b \
                    --routing-profile-id $routing_id_b \
                    --media-concurrencies "file://$helper/routingConcurrency_$routing_name.json" || error $LINENO

                aws_connect describe-routing-profile \
                    --instance-id $instance_id_b \
                    --routing-profile-id $routing_id_b \
                    > "$instance_alias_dir_b/$routing_json" || error $LINENO
            fi
        fi

#### Start of if queue configuration not same between source and destination routing profiles
        if [ "$df_rq" != "same" ]; then
            cat "$instance_alias_dir_a/routingQs_$routing_name.json" |
   ##           jq -r ".RoutingProfileQueueConfigSummaryList[].QueueName" |
   ## Above is commented out as it does not work if only priority and/or delay seconds are changed
                jq -r ".RoutingProfileQueueConfigSummaryList[]| {QueueName, Priority, Delay, Channel}" | jq -c |
                   sort > $TEMPA
## sort -u is an issue if other channel for same queue name is enable; so removing "-u"
#                sort -u > $TEMPA

            cat "$instance_alias_dir_b/routingQs_$routing_name.json" |
   ##             jq -r ".RoutingProfileQueueConfigSummaryList[].QueueName" |
   ## Above is commented out as it does not work if only priority and/or delay seconds are changed
                jq -r ".RoutingProfileQueueConfigSummaryList[]| {QueueName, Priority, Delay, Channel}" | jq -c |
                sort > $TEMPB
## sort -u is an issue if other channel for same queue name is enable; so removing "-u"
#                sort -u > $TEMPB
            > $TEMPA2
            diff $TEMPA $TEMPB | grep "^< " | sed -e"s/^< //" | cut  -d',' -f1 | sed -e "s/{\"QueueName\"://g" | sed "s/\"//g" | sort -u |
            tee $TEMPA3 |
################ while start reading qconfiguration updates
            while read q_name; do
                > $TEMPA2
                > $TEMPA4
	### Following is used to associate queue to routing profile
                cat "$instance_alias_dir_a/routingQs_$routing_name.json" |
                    jq -r ".RoutingProfileQueueConfigSummaryList[] | select(.QueueName == \"$q_name\") | { QueueReference: { QueueId, Channel }, Priority, Delay }" >> $TEMPA2
	        cat $TEMPA2 | sed -f "$helper_sed" | jq -s > "$helper/routingQueueConfig_$routing_name.json"

	### Following is used to disassociate queue from routing profile
                cat "$instance_alias_dir_a/routingQs_$routing_name.json" |
                    jq -r ".RoutingProfileQueueConfigSummaryList[] | select(.QueueName == \"$q_name\") | { QueueId, Channel }" >> $TEMPA4
	        cat $TEMPA4 | sed -f "$helper_sed" | jq -s > "$helper/routingQueueConfigDIS_$routing_name.json"

                cat <<EOD >> "$helper_log"

$actionLead Associate queues to routing profile: $routing_name_decoded
EOD
               if [ -n "$dryrun" ]; then
                   cat <<EOD
Dry-associate queues to routing profile $routing_name_decoded
$(cat $TEMPA3)
$(cat $TEMPFILE)

EOD
                  cat <<EOD >> "$helper_log"
aws connect associate-routing-profile-queues \
--instance-id $instance_id_b \
--routing-profile-id $routing_id_b \
--queue-configs "file://$helper/routingQueueConfig_$routing_name.json"
EOD
                # rm "$helper/routingQueueConfig_$routing_name.json"
               else
	   	   ## It is not a dry run
		   ## First we need to disassociate queue config from routing profile and then associate it.
		   ## This is to make sure if only "Priority" and/or "Delay" parameters are changed in source then we are able to update it.
                   aws_connect disassociate-routing-profile-queues \
       	            --instance-id $instance_id_b \
               	    --routing-profile-id $routing_id_b \
                    --queue-references "file://$helper/routingQueueConfigDIS_$routing_name.json" || error $LINENO

                   aws_connect associate-routing-profile-queues \
       	            --instance-id $instance_id_b \
               	    --routing-profile-id $routing_id_b \
                    --queue-configs "file://$helper/routingQueueConfig_$routing_name.json" || error $LINENO
               fi   ### End of if dry run check

        done   ################ end of while for updating qconfiguration

	## If there was something different between source and destination instance and if we can't update
	## e.g. routing profile exists in both instances but queue configuration is fewer in source than in destination
	##      This can happen when someone updated the routing profile to remove a queue in source instance 
	if [ ! -s "$TEMPA3" -a -z "$dryrun" ]; then
		echo "Skipping this update. Please update $routing_json manually."
		echo "$routing_json|$routing_id_b" >> $helper_skip

                aws_connect list-routing-profile-queues \
                    --instance-id $instance_id_b \
                    --routing-profile-id $routing_id_b \
                    > "$instance_alias_dir_b/routingQs_$routing_name.json" || error $LINENO
	fi
     fi   #### End of if queue configuration not same between source and destination routing profiles
    done  ##### While end reading routing json
    test $? -eq 0 || error
fi
### End if for routing profiles to update

################ Associate Lex bot to Connect instance in destination account
###
# Associate what is in $helper_new
egrep "^lex_" "$helper_new" | sort -u > $TEMPNEW
if [ ! -s $TEMPNEW ]; then
	echo "No bots to associate"
else
	num_bots=$(echo $(cat $TEMPNEW | wc -l))
	echo -e "\nAssociating $num_bots Lex bots"
	ii=0
	sort $TEMPNEW |
	while read botname; do
		ii=$[ii+1]
		echo "$ii. $botname"
		bot_name=${botname#lex_}
                cnt=`echo $bot_name | grep : | wc -l`
                if [ "$cnt" == "1" ]; then
                        ## This is Lex V2 bot
			lexversion=v2
                        botnameV2=`echo $bot_name | cut -f1 -d':'`
                        botaliasV2=`echo $bot_name | cut -f2 -d':'`
			## Get bot-Id of this V2 bot
			v2botid=`aws lexv2-models list-bots --profile $aws_profile_b | jq -r ".botSummaries[] | select(.botName == \"$botnameV2\") | { botId }" | jq -r ".botId"`
			## now get alias-id using botid
			v2aliasid=`aws lexv2-models list-bot-aliases --profile $aws_profile_b --bot-id $v2botid | jq -r ".botAliasSummaries[] | select(.botAliasName == \"$botaliasV2\") | { botAliasId }" | jq -r ".botAliasId"`
			## Now create bot Alias arn
			v2aliasarn=arn:aws:lex:$region_b:$account_b:bot-alias/$v2botid/$v2aliasid

			if [ -n "$dryrun" ]; then
				cat <<EOD
Dry-associating lambda function
--instance-id $instance_id_b \
--lex-v2-bot AliasArn=$v2aliasarn \

EOD
				cat <<EOD >> "$helper_log"
 
aws connect associate-bot \
--instance-id $instance_id_b \
--lex-v2-bot AliasArn=$v2aliasarn
EOD
		                continue
			fi
                else
                        ## This is Lex V1 bot
			lexversion=v1
			if [ -n "$dryrun" ]; then
				cat <<EOD
Dry-associating lambda function
--instance-id $instance_id_b \
--lex-bot Name=$bot_name,LexRegion=$region_b \

EOD
				cat <<EOD >> "$helper_log"

aws connect associate-bot \
--instance-id $instance_id_b \
--lex-bot Name=$bot_name,LexRegion=$region_b
EOD
		                continue
			fi
                fi

		## Not a dry run
		if [ "$lexversion" = "v1" ]; then
			aws_connect associate-bot \
				--instance-id $instance_id_b \
				--lex-bot Name=$bot_name,LexRegion=$region_b || error $LINENO
		else
			aws_connect associate-bot \
				--instance-id $instance_id_b \
				--lex-v2-bot AliasArn=$v2aliasarn || error $LINENO
		fi
	done
fi

############################################################
#
# Contact Flow Modules
#

cat <<EOD

Contact Flow Modules Creation
-----------------------------
EOD

# Preload as $helper_old may change
## Commenting out below egrep and adding one below. Only searching with "modules_"
##egrep "^module_$contact_flow_prefix" "$helper_old" > $TEMPOLD
egrep "^module_" "$helper_old" > $TEMPOLD
# Create what is in $helper_new
## Commenting out below egrep and adding one below. Only searching with "modules_"
#egrep "^module_$contact_flow_prefix" "$helper_new" > $TEMPNEW
egrep "^module_" "$helper_new" > $TEMPNEW
if [ ! -s $TEMPNEW ]; then
    echo "No contact flow modules$contact_flow_prefix_text to create"
else
    num_modules=$(echo $(cat $TEMPNEW | wc -l))
    echo -e "\nCreating $num_modules contact flow modules$contact_flow_prefix_text"
    ii=0
    sort $TEMPNEW |
    while read module_json; do
        ii=$[ii+1]
        echo "$ii. $module_json"
        module_name=${module_json#module_}
        module_name=${module_name%.json}
        module_name_decoded=$(path_decode "$module_name")

        ## module_id_a=$(jq -r "select(.Name == \"$module_name_decoded\") | .Id" "$instance_alias_dir_a/modules.json")
        module_id_a=$(sed -e's/\\"/%22/g' "$instance_alias_dir_a/modules.json" | jq -r "select(.Name == \"${module_name_decoded//\"/%22}\") | .Id") 
       out_file="$helper/output_$module_json"

        # Contact Flow Module template file
        # module_template_file=$helper/module_template.json

        cat "$instance_alias_dir_a/$module_json" |
        sed -f "$helper_sed" > "$helper/$module_json"

        cat <<EOD >> "$helper_log"

$actionLead Create contact flow module: $module_name_decoded
EOD
        if [ -n "$dryrun" ]; then
            cat <<EOD
Dry-create contact flow module
--instance-id $instance_id_b
--name "$module_name_decoded"

EOD
            cat <<EOD >> "$helper_log"
aws connect create-contact-flow-module \
--instance-id $instance_id_b \
--name "$module_name_decoded" \
--content "file://$helper/$module_json" \
> "$out_file"
EOD
            # rm "$helper/$module_json"
            continue
        fi

	## Get module description and use during module creation
	md="$instance_alias_dir_a/moduledesc_${module_name}"
	if [ -s "$md" ]; then
		module_desc=`cat "$md"`
	fi
	if [ "$module_desc" = "" -o "$module_desc" = null ]; then
		module_desc="$module_name_decoded"
	fi

        aws_connect create-contact-flow-module \
            --instance-id $instance_id_b \
            --name "$module_name_decoded" \
            --description "$module_desc" \
            --content "file://$helper/$module_json" \
            > "$out_file" || error $LINENO
        module_id_b=$(jq -r ".Id" "$out_file")

        # All flows will be updated with content
        # echo "$module_json" >> $TEMPOLD

        aws_connect describe-contact-flow-module \
            --instance-id $instance_id_b \
            --contact-flow-module-id $module_id_b \
            > $TEMPFILE || error $LINENO
        cat $TEMPFILE |
        jq -r '.ContactFlowModule.Content' > "$instance_alias_dir_b/$module_json"

## Creating list of newly created resources that can be deleted from instance B
	echo "module_${module_name_decoded}|$module_id_b" >> $helper_del
###############

        # Moving module_json from helper_new to helper_old
        echo "$module_json" >> "$helper_old"
        sed -e"/$module_json/d" "$helper_new" > $TEMPFILE
        cat $TEMPFILE > "$helper_new"

        cat <<EOD >> "$helper_sed"
# Contact Flow Module: $module_name_decoded
s%$module_id_a%$module_id_b%g
EOD
    done
    test $? -eq 0 || error

    if [ -z "$dryrun" ]; then
        # Update instance B flow modules
        aws_connect list-contact-flow-modules \
            --instance-id $instance_id_b \
            > $TEMPFILE || error $LINENO
        cat $TEMPFILE |
        jq -r ".ContactFlowModulesSummaryList[] | select(.Name | test(\"^($contact_flow_prefix|Default ).*\"))" \
        > "$instance_alias_dir_b/modules.json"
    fi
fi


cat <<EOD

Contact Flow Modules Update
---------------------------
EOD

if [ ! -s $TEMPOLD ]; then
    echo "No contact flow modules to update"
else
    num_modules=$(echo $(cat $TEMPOLD | wc -l))
    echo -e "\nChecking $num_modules contact flow modules$contact_flow_prefix_text for an update"
    ii=0
    sort $TEMPOLD |
    while read module_json; do
        ii=$[ii+1]
        echo -n "$ii. $module_json ... "
        module_name=${module_json#module_}
        module_name=${module_name%.json}
        module_name_decoded=$(path_decode "$module_name")

 	## we need to find exact module name match - use regular expressions ^ and $ ignoring case ("i")
        module_id_b=$(sed -e's/\\"/%22/g' "$instance_alias_dir_b/modules.json" | jq -r "select(.Name | match(\"^${module_name_decoded//\"/%22}$\";\"i\")) | .Id")
	## if module name has some exception characters, lower-case/upper-case differences, brackets, etc. and if we cannot find the id then skip instead of generating error
	skip_module="n"
	if [ "$module_id_b" == "" ]; then
		module_id_b=$(sed -e's/\\"/%22/g' "$instance_alias_dir_b/modules.json" | jq -r "select(.Name == \"${module_name_decoded//\"/%22}\") | .Id")
		if [ $module_id_b == "" ]; then
			skip_module="y"
		fi
	fi
 
        cat "$instance_alias_dir_a/$module_json" > $TEMPA
        cat "$instance_alias_dir_b/$module_json" > $TEMPB
        df=$(diff_files); echo $df; test "$df" == "same" && continue

        cat "$instance_alias_dir_a/$module_json" |
        sed -f "$helper_sed" > "$helper/$module_json"

        cat <<EOD >> "$helper_log"

$actionLead Update contact flow module: $module_name_decoded
EOD
        if [ -n "$dryrun" ]; then
            cat <<EOD
Dry-update contact flow module
--instance-id $instance_id_b
--contact-flow-module-id $module_id_b

EOD
            cat <<EOD >> "$helper_log"
aws connect update-contact-flow-module-content \
--instance-id $instance_id_b \
--contact-flow-module-id $module_id_b \
--content "file://$helper/$module_json" \
> "$helper/output_content_$module_json"
EOD
            # rm "$helper/$module_json"
            continue
        fi

############################################################################
### Check if this is part of exception module that we have to skip updating
### (e.g. it can contain reference to claimed number from source account
###       set in "Set caller Id" block in outbound whisper or transfer flow

	cnt=`grep -f $flowExceptions "$instance_alias_dir_a/$module_json" | wc -l`
       	if [ $cnt -gt 0 -o "$skip_module" == "y" ]; then
        	echo "Skipping this update as it contains an exception - Either reference to claimed number from source instance, or hard-coded Agent queue ARN. Please update this module manually in destination account."
		echo "$module_json|$module_id_b" >> $helper_skip
	else
	        aws_connect update-contact-flow-module-content \
        	    --instance-id $instance_id_b \
            	--contact-flow-module-id $module_id_b \
            	--content "file://$helper/$module_json" \
            	> "$helper/output_content_$module_json" || error $LINENO
	fi
        aws_connect describe-contact-flow-module \
            --instance-id $instance_id_b \
            --contact-flow-module-id $module_id_b \
            > $TEMPFILE || error $LINENO
        cat $TEMPFILE |
        jq -r '.ContactFlowModule.Content' > "$instance_alias_dir_b/$module_json"
    done
    test $? -eq 0 || error
fi



############################################################
#
# Contact Flows
#
# TODO:
#   - Use $helper/flow_template.json as a template to create new contact flows
#   - Use the Default special type contact flow to create special type contact flows
#   - Skip "Default " and "Sample " contact flows

cat <<EOD

Contact Flows Creation
----------------------
EOD

# Preload as $helper_old may change
## Changing egrep to only use "flow_" Original egrep is commented out and updated on added below that
## egrep "^flow_$contact_flow_prefix" "$helper_old" | egrep -v "^flow_Default |^flow_Sample " > $TEMPOLD
egrep "^flow_" "$helper_old" | egrep -v "^flow_Default |^flow_Sample " > $TEMPOLD
# Create what is in $helper_new
## Changing egrep to only use "flow_" Original egrep is commented out and updated on added below that
## egrep "^flow_$contact_flow_prefix" "$helper_new" > $TEMPNEW
egrep "^flow_" "$helper_new" > $TEMPNEW
if [ ! -s $TEMPNEW ]; then
    echo "No contact flows$contact_flow_prefix_text to create"
else
    num_flows=$(echo $(cat $TEMPNEW | wc -l))
    echo -e "\nCreating $num_flows contact flows$contact_flow_prefix_text"
    ii=0
    sort $TEMPNEW |
    while read flow_json; do
        ii=$[ii+1]
        echo "$ii. $flow_json"
        flow_name=${flow_json#flow_}
        flow_name=${flow_name%.json}
        flow_name_decoded=$(path_decode "$flow_name")

        # flow_type=$(jq -r "select(.Name == \"${flow_name_decoded//\"/\\\"}\") | .ContactFlowType" "$instance_alias_dir_a/flows.json")
        flow_type=$(sed -e's/\\"/%22/g' "$instance_alias_dir_a/flows.json" | jq -r "select(.Name == \"${flow_name_decoded//\"/%22}\") | .ContactFlowType")
        # flow_id_a=$(jq -r "select(.Name == \"${flow_name_decoded//\"/\\\"}\") | .Id" "$instance_alias_dir_a/flows.json")
        flow_id_a=$(sed -e's/\\"/%22/g' "$instance_alias_dir_a/flows.json" | jq -r "select(.Name == \"${flow_name_decoded//\"/%22}\") | .Id")

        out_file="$helper/output_$flow_json"

        # Contact Flow template file
        flow_template_file=$helper/flow_template.json
        case "$flow_type" in
        CUSTOMER_QUEUE)
            flow_template_file="$instance_alias_dir_b/flow_Default%20customer%20queue.json";;
        CUSTOMER_HOLD)
            flow_template_file="$instance_alias_dir_b/flow_Default%20customer%20hold.json";;
        CUSTOMER_WHISPER)
            flow_template_file="$instance_alias_dir_b/flow_Default%20customer%20whisper.json";;
        AGENT_HOLD)
            flow_template_file="$instance_alias_dir_b/flow_Default%20agent%20hold.json";;
        AGENT_WHISPER)
            flow_template_file="$instance_alias_dir_b/flow_Default%20agent%20whisper.json";;
        OUTBOUND_WHISPER)
            flow_template_file="$instance_alias_dir_b/flow_Default%20outbound.json";;
        AGENT_TRANSFER)
            flow_template_file="$instance_alias_dir_b/flow_Default%20agent%20transfer.json";;
        QUEUE_TRANSFER)
            flow_template_file="$instance_alias_dir_b/flow_Default%20queue%20transfer.json";;
        esac

        cat <<EOD >> "$helper_log"

$actionLead Create contact flow: $flow_name_decoded
EOD
        if [ -n "$dryrun" ]; then
            cat <<EOD
Dry-create contact flow from Template (Default flows)
--instance-id $instance_id_b
--name "$flow_name_decoded"
--type $flow_type

EOD
            cat <<EOD >> "$helper_log"
aws connect create-contact-flow \
--instance-id $instance_id_b \
--name "$flow_name_decoded" \
--type $flow_type \
--content "file://$flow_template_file" \
> "$out_file"
EOD
            continue
        fi

	## Get flow description and use during flow creation
	fd="$instance_alias_dir_a/flowdesc_${flow_name_decoded}"
	if [ -s "$fd" ]; then
		flow_desc=`cat "$fd"`
	fi
	if [ "$flow_desc" = "" -o "$flow_desc" = null ]; then
		flow_desc="$flow_name_decoded"
	fi
        aws_connect create-contact-flow \
            --instance-id $instance_id_b \
            --name "$flow_name_decoded" \
            --type $flow_type \
            --description "$flow_desc" \
            --content "file://$flow_template_file" \
            > "$out_file" || error $LINENO
        flow_id_b=$(jq -r ".ContactFlowId" "$out_file")

        # All flows will be updated with content
        echo "$flow_json" >> $TEMPOLD

        aws_connect describe-contact-flow \
            --instance-id $instance_id_b \
            --contact-flow-id $flow_id_b \
            > $TEMPFILE || error $LINENO
        cat $TEMPFILE |
        jq -r '.ContactFlow.Content' > "$instance_alias_dir_b/$flow_json"

## Creating list of newly created resources that can be deleted from instance B
	echo "flow_${flow_name_decoded}|$flow_id_b" >> $helper_del
###############

        # Moving flow_json from helper_new to helper_old
        echo "$flow_json" >> "$helper_old"
        sed -e"/$flow_json/d" "$helper_new" > $TEMPFILE
        cat $TEMPFILE > "$helper_new"

        cat <<EOD >> "$helper_sed"
# Contact Flow: $flow_name_decoded
s%$flow_id_a%$flow_id_b%g
EOD
    done
    test $? -eq 0 || error

    if [ -z "$dryrun" ]; then
        # Update instance B flows
        aws_connect list-contact-flows \
            --instance-id $instance_id_b \
            > $TEMPFILE || error $LINENO
        cat $TEMPFILE |
        jq -r ".ContactFlowSummaryList[] | select(.Name | test(\"^($contact_flow_prefix|Default ).*\"))" \
        > "$instance_alias_dir_b/flows.json"
    fi
fi


cat <<EOD

Contact Flows Update
--------------------
EOD

if [ ! -s $TEMPOLD ]; then
    echo "No contact flows to update"
else
    num_flows=$(echo $(cat $TEMPOLD | wc -l))
    echo -e "\nChecking $num_flows contact flows$contact_flow_prefix_text for an update"
    ii=0
    sort $TEMPOLD |
    while read flow_json; do
        ii=$[ii+1]
        echo -n "$ii. $flow_json ... "
        flow_name=${flow_json#flow_}
        flow_name=${flow_name%.json}
        flow_name_decoded=$(path_decode "$flow_name")

	## we need to find exact flow name match - use regular expressions ^ and $ ignoring case ("i")
	flow_id_b=$(sed -e's/\\"/%22/g' "$instance_alias_dir_b/flows.json" | jq -r "select(.Name | match(\"^${flow_name_decoded//\"/%22}$\";\"i\")) | .Id")
	## if flow name has some exception characters, lower-case/upper-case differences, brackets, etc. and if we cannot find the id then skip instead of generating error
	skip_flow="n"
	if [ "$flow_id_b" == "" ]; then
	        flow_id_b=$(sed -e's/\\"/%22/g' "$instance_alias_dir_b/flows.json" | jq -r "select(.Name == \"${flow_name_decoded//\"/%22}\") | .Id")
		if [ $flow_id_b == "" ]; then
			skip_flow="y"
		fi
	fi

        cat "$instance_alias_dir_a/$flow_json" > $TEMPA
        cat "$instance_alias_dir_b/$flow_json" > $TEMPB
        df=$(diff_files); echo $df; test "$df" == "same" && continue

        cat "$instance_alias_dir_a/$flow_json" |
        sed -f "$helper_sed" > "$helper/$flow_json"

        cat <<EOD >> "$helper_log"

$actionLead Update contact flow: $flow_name_decoded
EOD
        if [ -n "$dryrun" ]; then
            cat <<EOD
Dry-update contact flow
--instance-id $instance_id_b
--contact-flow-id $flow_id_b

EOD
            cat <<EOD >> "$helper_log"
aws connect update-contact-flow-content \
--instance-id $instance_id_b \
--contact-flow-id $flow_id_b \
--content "file://$helper/$flow_json" \
> "$helper/output_content_$flow_json"
EOD
            # rm "$helper/$flow_json"
            continue
        fi

############################################################################
### Check if this is part of exception flow that we have to skip updating
### (e.g. it can contain reference to claimed number from source account
###       set in "Set caller Id" block in outbound whisper or transfer flow

	cnt=`grep -f $flowExceptions "$instance_alias_dir_a/$flow_json" | wc -l`
       	if [ $cnt -gt 0 -o "$skip_flow" == "y" ]; then
        	echo "Skipping this update as it contains an exception - Either reference to claimed number from source instance, or hard-coded Agent queue ARN. Please update this flow manually in destination account."
		echo "$flow_json|$flow_id_b" >> $helper_skip
	else
	      aws_connect update-contact-flow-content \
      		      --instance-id $instance_id_b \
      	     	 --contact-flow-id $flow_id_b \
           	 --content "file://$helper/$flow_json" \
          	  > "$helper/output_content_$flow_json" || error $LINENO
	fi
        aws_connect describe-contact-flow \
            --instance-id $instance_id_b \
            --contact-flow-id $flow_id_b \
            > $TEMPFILE || error $LINENO
        cat $TEMPFILE |
        jq -r '.ContactFlow.Content' > "$instance_alias_dir_b/$flow_json"
    done
    test $? -eq 0 || error
fi


############################################################
#
# Contact flows and modules association with Lambda functions
#

lambdaArnLead=arn:aws:lambda:$region_b:$aws_ac_b:function:
cat \
    "$instance_alias_dir_b/flow_"* \
    "$instance_alias_dir_b/module_"* 2> /dev/null |
    jq -r ".Actions[] | select(.Type == \"InvokeLambdaFunction\") | .Parameters.LambdaFunctionARN" |
    grep "$lambdaArnLead" |
    sort -u > $TEMPFILE

if [ -s $TEMPFILE ]; then
    echo
    echo Associating Lambda functions to $instance_alias_b
    # Use "aws connect" instead of "aws_connect" to avoid logging
aws connect list-lambda-functions \
$profile_flag \
--instance-id $instance_id_b \
> $TEMPOLD || error $LINENO
    cat $TEMPOLD |
    jq -r ".LambdaFunctions" > "$helper/lambds.json"

    ii=0
    cat $TEMPFILE |
    while read lambdaArn; do
        ii=$[ii+1]
        echo -n "$ii. $lambdaArn ... "
        lambdaExist=$(echo $(cat "$helper/lambds.json" | jq ".[] | select(. == \"$lambdaArn\")" | wc -l))
        if [ "$lambdaExist" -gt 0 ]; then
            echo "already associated"
            continue
        fi
        echo "to be associated"
        if [ -n "$dryrun" ]; then
            cat <<EOD
Dry-associating lambda function
--instance-id $instance_id_b \
--function-arn $lambdaArn \


EOD
            cat <<EOD >> "$helper_log"

aws connect associate-lambda-function \
--instance-id $instance_id_b \
--function-arn $lambdaArn
EOD
            continue
        fi
        aws_connect associate-lambda-function \
            --instance-id $instance_id_b \
            --function-arn $lambdaArn || error $LINENO
    done
fi

############################################################
#
# Quick Connects
#

cat <<EOD

Quick Connects
-----------------
EOD

# Preload as $helper_old may change
egrep "^quickconnect_" "$helper_old" > $TEMPOLD
# Create what is in $helper_new
egrep "^quickconnect_" "$helper_new" > $TEMPNEW
if [ ! -s $TEMPNEW ]; then
	echo "No Quick Connects to create"
else
	num_qc=$(echo $(cat $TEMPNEW | wc -l))
	echo -e "\nCreating $num_qc Quick Connects"
	ii=0
	sort $TEMPNEW |
	while read qc_json; do
		ii=$[ii+1]
		echo "$ii. $qc_json"
		qc_name=${qc_json#quickconnect_}
		qc_name=${qc_name%.json}
	        qc_name_decoded=$(path_decode "$qc_name")
		qc_id_a=$(jq -r ".QuickConnect.QuickConnectId" "$instance_alias_dir_a/$qc_json")
		cat "$instance_alias_dir_a/$qc_json" |
			jq --arg instance_id $instance_id_b \
			".QuickConnect | del(.QuickConnectARN, .QuickConnectId) | . + { InstanceId: \$instance_id}" |
			sed -f "$helper_sed" > "$helper/$qc_json"

		cat <<EOD >> "$helper_log"
$actionLead Create Quick Connect: $qc_name_decoded
EOD

		if [ -n "$dryrun" ]; then
			cat <<EOD
			Dry-create Quick Connect
			$(cat "$helper/$qc_json")

EOD
            		cat <<EOD >> "$helper_log"
aws connect create-quick-connect \
--cli-input-json "file://$helper/$qc_json" \
> "$helper/output_$qc_json"
EOD
			# rm "$helper/$qc_json"
	                continue
		fi

############################################################################
### Check if this is part of exception that we have to skip 
### (e.g. quick connect is of type USER
	    cnt=`grep -f $flowExceptions "$instance_alias_dir_a/$qc_json" | wc -l`
       	    if [ $cnt -gt 0 ]; then
        	echo "Skipping this quick connect as it contains an exception - May have quick connect type as USER. Please update this quick connect manually in destination account."
		echo "$qc_json|dummyid" >> $helper_skip
   	    else
		aws_connect create-quick-connect \
			--cli-input-json "file://$helper/$qc_json" \
			> "$helper/output_$qc_json" || error $LINENO
			qc_id_b=$(jq -r ".QuickConnectId" "$helper/output_$qc_json")

		aws_connect describe-quick-connect \
			--instance-id $instance_id_b \
			--quick-connect-id $qc_id_b \
			> "$instance_alias_dir_b/$qc_json" || error $LINENO

## Creating list of newly created resources that can be deleted from instance B
		echo "qc_${qc_name_decoded}|$qc_id_b" >> $helper_del

###############
		# Moving qc_json from helper_new to helper_old
		echo $qc_json >> "$helper_old"
		sed -e"/$qc_json/d" "$helper_new" > $TEMPFILE
		cat $TEMPFILE > "$helper_new"
		cat <<EOD >> "$helper_sed"

		# Quick Connect: $qc_name_decoded
		s%$qc_id_a%$qc_id_b%g
EOD
	    fi
    	done
    	test $? -eq 0 || error

	if [ -z "$dryrun" ]; then
		# Update instance B quick connects
		aws_connect list-quick-connects \
			--instance-id $instance_id_b \
			> $TEMPFILE || error $LINENO
		cat $TEMPFILE |
			jq -r ".QuickConnectSummaryList[]" > "$instance_alias_dir_b/quickconnects.json"
	fi
fi

### Let's check if we need to update any quick connects
if [ ! -s $TEMPOLD ]; then
	    echo "No Quick Connects to update"
    else
	num_qc=$(echo $(cat $TEMPOLD | wc -l))
        echo -e "\nChecking $num_qc Quick Connects for an update"
	ii=0
	sort $TEMPOLD |
	while read qc_json; do
        	ii=$[ii+1]
	        echo -n "$ii. $qc_json ... "
		cat "$instance_alias_dir_a/$qc_json" > $TEMPA
		cat "$instance_alias_dir_b/$qc_json" > $TEMPB
		df=$(diff_files); echo $df; test "$df" == "same" && continue
		echo "Please update $qc_json manually considering potential operation impact."
		## Lets record that we skipped this update
		echo "$qc_json|dummyId" >> $helper_skip
	done
fi

############################################################
#
# Associate Quick Connects to Queues
#
#
cat <<EOD

Queues - Quick Connects
------
EOD

# Preload as $helper_old may change
egrep "^queue_" "$helper_old" > $TEMPOLD
if [ ! -s $TEMPOLD ]; then
    echo "No queues to update with quick connects"
else
    num_queues=$(echo $(cat $TEMPOLD | wc -l))
    echo -e "\nChecking $num_queues queues for quick connect association"
    ii=0
    sort $TEMPOLD |
    while read queue_json; do
        ii=$[ii+1]
        queue_qc_json="queue_qc_"${queue_json#queue_}
        echo -n "$ii. $queue_qc_json ... "
        cat "$instance_alias_dir_a/$queue_qc_json" > $TEMPA
        cat "$instance_alias_dir_b/$queue_qc_json" > $TEMPB
        df=$(diff_files); echo $df; test "$df" == "same" && continue

	if [ -z "$dryrun" ]; then
		## We need to associate quick connect to this queue
		queue_id_b=$(jq -r ".Queue.QueueId" "$instance_alias_dir_b/$queue_json")
	        cat "$instance_alias_dir_a/$queue_qc_json" | sed -f "$helper_sed" > "$helper/$queue_qc_json"
		## Associate all quick connects to this queue but skip the quick connect type USER
		cat "$helper/$queue_qc_json" | jq -r ".QuickConnectSummaryList[] | select (.QuickConnectType != \"USER\") | .Id" |
		while read qcid; do
			aws_connect associate-queue-quick-connects \
				--instance-id $instance_id_b --queue-id $queue_id_b --quick-connect-ids $qcid \
				> $TEMPFILE || error $LINENO
		done
		cnt=`cat "$helper/$queue_qc_json" | jq -r ".QuickConnectSummaryList[] | select (.QuickConnectType == \"USER\") | .Id" | wc -l`
		if [ "$cnt" -gt "0" ]; then
			## There is a quick connect in this queue of type USER - Mark it to update this queue manually
			echo "$queue_qc_json|qQC" >> $helper_skip
		fi
	fi
    done
fi


###########################################################################################################
### Let's check if we skipped to update any resources
## Check if we skipped routing profile update
echo
echo
echo
echo "******************* Possible actions in destination instance *******************"
echo "******************* Please check these resources in destination instance *******************"
for resource in hour queue routing module flow quickconnect; do
	case "$resource" in
   	"hour")
      	   rsc_desc="Hours of operation"
 	   ;;
   	"queue")
      	   rsc_desc="Queues"
 	   ;;
   	"routing")
      	   rsc_desc="Routing profiles"
 	   ;;
   	"module")
      	   rsc_desc="Contact Module"
 	   ;;
   	"flow")
      	   rsc_desc="Contact flows"
 	   ;;
   	"quickconnect")
      	   rsc_desc="Quick connects"
 	   ;;
	esac

        > $TEMPNEW
        egrep "^${resource}_" "$helper_skip" > $TEMPNEW
        if [ -s $TEMPNEW ]; then
            num_hours=$(echo $(cat $TEMPNEW | wc -l))
            echo -e "\nSkipped $num_hours "$rsc_desc" for create/update"
            ii=0
            sort $TEMPNEW |
            while read line1; do
                ii=$[ii+1]
                resource_json=`echo $line1 | cut -d'|' -f1`
                resource_id=`echo $line1 | cut -d'|' -f2`
                resource_name=${resource_json#${resource}_}
                resource_name=${resource_name%.json}
		if [ "$resource_id" == "qQC" ]; then
	                resource_name=${resource_name#qc_}
	                echo "$ii. Quick connects in queue: $resource_name"
		else
	                echo "$ii. $resource_name"
		fi
            done
        fi
done
echo "*********************************************"

##############################################
num_actions=$(echo $(egrep "^$actionLead" "$helper_log" | wc -l))
echo
#echo "$num_actions actions on the target instance"
if [ "$num_actions" -eq 0 ]; then
    echo "Target instance is the same as the source instance. No updates are required."
    exit 3
else
    echo
##    cat "$helper_log"
##    echo
    if [ -n "$dryrun" ]; then
        echo "No actions were carried out in Dry-run mode"
    else
        echo "All done"
    fi
fi


