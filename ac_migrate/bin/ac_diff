#!/bin/bash

############################################################
#
# Find the differences of instance A and instance B and produce helper files.
# Note: This script does not use AWS CLI but instead uses results from
#   connect_list on instance A and B.
#
# Added support to use mapping file for Lambda and Lex
# This is useful when Lambda function name in destination account is different then in source account
# 
#

USAGE=$(cat <<EOD
Usage: $(basename $0) [-?fe] instance_alias_a instance_alias_b helper [lambda_prefix_a] [lambda_prefix_b]
    Based on connect_list result on Amazon Connect instance A and B,
    find the differences and produce helper files to safely copy resources from A to B.

    instance_alias_a  Alias of the Connect instance A
    instance_alias_b  Alias of the Connect instance B
                      (Aliases can be a path to the directory where the instance was saved using connect_save.)
    helper            Name of the helper directory
    lambda_prefix_a   Lambda function name prefix in instance A to be replaced with <lambda_prefix_b>
    lambda_prefix b   Lambda function name prefix in instance B replacing <lambda_prefix_a>
    -f                Force removal of existing helper directory
    -e                Proceed even when the Bash shell may not encode Extended ASCII characters properly
    -?                Help

    Note: This script create files in the helper directory without changing any instance resource files.
EOD
)
usage() { echo -e "$USAGE" >&2; exit 2; }

error() { echo -e "Error: $1" >&2; exit 1; }

hex_code() { printf '%s' "$1" | xxd -u -p -c1 | while read x; do printf "%%%s" "$x"; done }

path_encode()  {
    old_lc_collate=$LC_COLLATE
    LC_COLLATE=C
    local length="${#1}"
    for (( i = 0; i < length; i++ )); do
        local c="${1:$i:1}"
        case $c in
            [a-zA-Z0-9.~_-]) printf '%s' "$c";;
            *) x=$(hex_code "$c"); echo -n ${x//%0D/};;
        esac
    done
    LC_COLLATE=$old_lc_collate
}

add_file() {
    alias_dir="$1"
    file_suffix="$2"
    helper_file="$3"
    if [ ! -s "$alias_dir/$file_suffix" ]; then
        error "File missing or empty: $alias_dir/$file_suffix"
        exit 1
    else
        echo "$file_suffix" >> $helper_file
    fi
}

###########################################################################################################
## Evaluate what resources exist in source instance and what in destination, and create old and new helper files
##
eval_resources() {
   restype="$1"
   resource="$2"
   resfile="$3"
   rp_to_ignore="$4"
   rpq="$5"
   
   jq -r ".Id + \" \" + .Name" "$instance_alias_dir_a"/"$resfile" |
   tr -d '\r' |
   while read resource_id_a resource_name_a; do
      if [ "$resource_name_a" == "$rp_to_ignore" ]; then
        continue
      fi
      resource_name_encoded_a=$(path_encode "$resource_name_a")
##      resource_id_b=$(jq -r "select(.Name == \"$resource_name_a\") | .Id" "$instance_alias_dir_b"/"$resfile")
##      resource_id_b=$(jq -r "select(.Name == \"${resource_name_a//\"/\\\"}\") | .Id" "$instance_alias_dir_b"/"$resfile")
      resource_id_b=$(sed -e's/\\"/%22/g' "$instance_alias_dir_b"/"$resfile" | jq -r "select(.Name == \"${resource_name_a//\"/%22}\") | .Id")
      if [ -z "$resource_id_b" ]; then
	## Resource does not exist in destination - let's do case insensitive check to make sure with regex (^ and $ for exact match)
	resource_id_b=$(jq -r -c "select(.Name | match(\"^$resource_name_a$\";\"i\")) |  .Id" "$instance_alias_dir_b"/"$resfile")
  	if [ -z "$resource_id_b" ]; then
		## Resource does not exist in destination
        	add_file "$instance_alias_dir_a" "${resource}${resource_name_encoded_a}.json" $helper_new
		## If resource is routing profile then we need to also account for queues configuration in routing profile
		if [ "$restype" = "RP" ]; then
		   add_file "$instance_alias_dir_a" "${rpq}${resource_name_encoded_a}.json" $helper_new
		fi
        else
		## Resource exists in destination but name in source and destination have some lower-upper case differences
		## Get the destination resource name and rename it to same name as source instance name
		resource_name_b=$(jq -r "select(.Id == \"$resource_id_b\") | .Name" "$instance_alias_dir_b"/"$resfile")
	        resource_name_encoded_b=$(path_encode "$resource_name_b")
		mv "$instance_alias_dir_b"/"${resource}${resource_name_encoded_b}.json" "$instance_alias_dir_b"/"${resource}${resource_name_encoded_a}.json"
        	add_file "$instance_alias_dir_b" "${resource}${resource_name_encoded_a}.json" $helper_old
		## If resource is routing profile then we need to also account for queues configuration in routing profile
		if [ "$restype" = "Queues" ]; then
		   ## if there is a case difference then set the name of queue quick connect same as source instance case
		   mv "$instance_alias_dir_b"/"${rpq}${resource_name_encoded_b}.json" "$instance_alias_dir_b"/"${rpq}${resource_name_encoded_a}.json"
		fi
		if [ "$restype" = "RP" ]; then
		   ## if there is a case difference then set the name of queue config in routing profile same as source instance case
		   mv "$instance_alias_dir_b"/"${rpq}${resource_name_encoded_b}.json" "$instance_alias_dir_b"/"${rpq}${resource_name_encoded_a}.json"
  		   add_file "$instance_alias_dir_b" "${rpq}${resource_name_encoded_a}.json" $helper_old
		fi
        	cat <<EOD >> $helper_sed
# Add Ids in sed file for replacement
s%$resource_id_a%$resource_id_b%g
EOD
       fi
    else
	## Resource exists in destination
        add_file "$instance_alias_dir_b" "${resource}${resource_name_encoded_a}.json" $helper_old
	## If resource is routing profile then we need to also account for queues configuration in routing profile
	if [ "$restype" = "RP" ]; then
	   add_file "$instance_alias_dir_b" "${rpq}${resource_name_encoded_a}.json" $helper_old
	fi
        cat <<EOD >> $helper_sed
# Add Ids in sed file for replacement
s%$resource_id_a%$resource_id_b%g
EOD
    fi
   done
   test $? -eq 0 || error
##
} ## End of eval_resources
###########################################################################################################


forced=
ignore_improper_extended_ascii=
while getopts "?fe" arg; do
    case "$arg" in
    f)  forced=on;;
    e)  ignore_improper_extended_ascii=on;;
    *)  usage;;
    esac
done
shift $((OPTIND-1))

if [ "$(hex_code "é")" != "%C3%A9" ]; then
    echo "WARNING: This Bash shell may not encode Extended ASCII characters properly." >&2
    if [ -n "$ignore_improper_extended_ascii" ]; then
        echo "Proceed regardless as the -e option is specified." >&2
    else
        cat <<EOD >&2

If your instance component names contain Extended ASCII characters, such as accented letters
like é, this Bash shell will encode those names differently from standard Bash shell encoding.

If you are sure that your component names do not contain Extended ASCII characters,
you may proceed regardless by running the command again with the -e option.
EOD
        exit 1
    fi
fi

instance_alias_dir_a=$1
instance_alias_a=$(basename "$instance_alias_dir_a")
instance_alias_dir_b=$2
instance_alias_b=$(basename "$instance_alias_dir_b")
# helper=${3:-${instance_alias_a}_TO_${instance_alias_b}}
helper=$3
lambda_prefix_a=$4
lambda_prefix_b=$5

## Set directories
homedir=`pwd`
rscdir="${homedir}/resources"

## Added resource name mapping to be replaced from src to dest account
## e.g. lambda src-function-name dest-function-name
resource_map="${rscdir}/resourceMap"

if [ -z "$instance_alias_a" -o -z "$instance_alias_b" -o -z "$helper" ]; then
    usage
fi

if [ -d $helper ]; then
    if [ -n "$forced" ]; then
        echo "Existing Helper directory forcefully removed: $helper"
        rm -fr $helper
    else
        error "Helper directory already exists. Remove and try again (or use -f): $helper"
    fi
fi

routing_profile_to_ignore="Basic Routing Profile"
flow_template=$helper/flow_template.json

cat <<EOD
Instance Alias A: $instance_alias_a (in directory "$instance_alias_dir_a")
Instance Alias B: $instance_alias_b (in directory "$instance_alias_dir_b")
Helper: $helper
EOD

errorMsg=
if [ ! -d "$instance_alias_dir_a" ]; then
    errorMsg="$errorMsg \"$instance_alias_dir_a\""
fi
if [ ! -d "$instance_alias_dir_b" ]; then
    errorMsg="$errorMsg \"$instance_alias_dir_b\""
fi
if [ -n "$errorMsg" ]; then
    errorMsg="Cannot find instance directories:$errorMsg"
    error "$errorMsg"
fi

mkdir -p $helper

for ext in var sed new old; do
    eval helper_$ext=$helper/helper.$ext
    eval fn=\$helper_$ext
    > $fn
done


############################################################
#
# Instance
#

echo "instance_alias_a=$instance_alias_a" | tee -a $helper_var
echo "instance_alias_dir_a=\"$instance_alias_dir_a\"" | tee -a $helper_var
echo "instance_alias_b=$instance_alias_b" | tee -a $helper_var
echo "instance_alias_dir_b=\"$instance_alias_dir_b\"" | tee -a $helper_var

. "$instance_alias_dir_a/instance.var"

instance_id_a=$instance_Id
instance_arn_a=$instance_Arn
eval $(echo $instance_arn_a | (IFS=: read x x x r a x; echo "region_a=$r; aws_ac_a=$a"))
region_a=$region_a
aws_ac_a=$aws_ac_a
aws_profile_a=$aws_Profile
echo instance_id_a=$instance_id_a | tee -a $helper_var
echo instance_arn_a=$instance_arn_a | tee -a $helper_var
echo region_a=$region_a | tee -a $helper_var
echo aws_ac_a=$aws_ac_a | tee -a $helper_var
echo aws_profile_a=$aws_Profile | tee -a $helper_var

. "$instance_alias_dir_b/instance.var"
instance_id_b=$instance_Id
instance_arn_b=$instance_Arn
eval $(echo $instance_arn_b | (IFS=: read x x x r a x; echo "region_b=$r; aws_ac_b=$a"))
region_b=$region_b
aws_ac_b=$aws_ac_b
aws_profile_b=$aws_Profile
echo instance_id_b=$instance_id_b | tee -a $helper_var
echo instance_arn_b=$instance_arn_b | tee -a $helper_var
echo region_b=$region_b | tee -a $helper_var
echo aws_ac_b=$aws_ac_b | tee -a $helper_var
echo aws_profile_b=$aws_Profile | tee -a $helper_var

# Use Instance B contact flow prefix
echo "contact_flow_prefix=\"$instance_contact_flow_prefix\"" | tee -a $helper_var


############################################################
#
# General SED commands
#

connect_arn_prefix_a="arn:aws:connect:$region_a:$aws_ac_a"
connect_arn_prefix_b="arn:aws:connect:$region_b:$aws_ac_b"
cat <<EOD >> $helper_sed
# General SED commands
s%$instance_id_a%$instance_id_b%g
s%$connect_arn_prefix_a%$connect_arn_prefix_b%g
EOD

### Read resource mapping file and add the sed commands
if [ -e "$resource_map" ]; then
   echo "Reading resource mapping to set up Lambda and Lex bots..."
   cat $resource_map | 
   while read res_type res_src res_dest; do
	if [ "$res_type" = "lambda" ]; then
		lambda_arn_prefix_a="arn:aws:lambda:$region_a:$aws_ac_a:function:$res_src"
		lambda_arn_prefix_b="arn:aws:lambda:$region_b:$aws_ac_b:function:$res_dest"
    		echo "s%$lambda_arn_prefix_a%$lambda_arn_prefix_b%g" >> $helper_sed
	fi

	if [ "$res_type" = "bot" ]; then
		## Check if this is bot type v2
		bot_name=$res_src
                cnt=`echo $bot_name | grep : | wc -l`
                if [ "$cnt" == "1" ]; then
                        ## This is Lex V2 bot
                        botnameV2=`echo $bot_name | cut -f1 -d':'`
                        botaliasV2=`echo $bot_name | cut -f2 -d':'`
			## Get bot-Id of this V2 bot
			v2botid=`aws lexv2-models list-bots --profile $aws_profile_a | jq -r ".botSummaries[] | select(.botName == \"$botnameV2\") | { botId }" | jq -r ".botId"`
			## now get alias-id using botid
			v2aliasid=`aws lexv2-models list-bot-aliases --profile $aws_profile_a --bot-id $v2botid | jq -r ".botAliasSummaries[] | select(.botAliasName == \"$botaliasV2\") | { botAliasId }" | jq -r ".botAliasId"`
			## Now create bot Alias arn
			v2aliasarn_a=arn:aws:lex:$region_a:$aws_ac_a:bot-alias/$v2botid/$v2aliasid
			bot_v2_a='"lexV2BotName":"'${botnameV2}'","lexV2BotAliasName":"'${botaliasV2}'"'

			## now find arn of destination instance bot
			bot_name=$res_dest
                        botnameV2=`echo $bot_name | cut -f1 -d':'`
                        botaliasV2=`echo $bot_name | cut -f2 -d':'`
			## Get bot-Id of this V2 bot
			v2botid=`aws lexv2-models list-bots --profile $aws_profile_b | jq -r ".botSummaries[] | select(.botName == \"$botnameV2\") | { botId }" | jq -r ".botId"`
			## now get alias-id using botid
			v2aliasid=`aws lexv2-models list-bot-aliases --profile $aws_profile_b --bot-id $v2botid | jq -r ".botAliasSummaries[] | select(.botAliasName == \"$botaliasV2\") | { botAliasId }" | jq -r ".botAliasId"`
			## Now create bot Alias arn
			v2aliasarn_b=arn:aws:lex:$region_b:$aws_ac_b:bot-alias/$v2botid/$v2aliasid
			bot_v2_b='"lexV2BotName":"'${botnameV2}'","lexV2BotAliasName":"'${botaliasV2}'"'
			echo "s%$bot_v2_a%$bot_v2_b%g" >> $helper_sed
	    		echo "s%$v2aliasarn_a%$v2aliasarn_b%g" >> $helper_sed
		else
			## This is v1 (Classic) bot
			## Bot name and region replacement for v1 type of bot
        	        bot_a='"LexBot":{"Name":"'${res_src}'","Region":"'${region_a}'"'
                	bot_b='"LexBot":{"Name":"'${res_dest}'","Region":"'${region_b}'"'
	 		echo "s%$bot_a%$bot_b%g" >> $helper_sed
		fi
       		echo "lex_$res_dest" >> $helper_new
	fi
   done
fi

lambda_arn_prefix_a="arn:aws:lambda:$region_a:$aws_ac_a:function:$lambda_prefix_a"
lambda_arn_prefix_b="arn:aws:lambda:$region_b:$aws_ac_b:function:$lambda_prefix_b"
if [ "$lambda_arn_prefix_a" != "$lambda_arn_prefix_b" ]; then
    echo "s%$lambda_arn_prefix_a%$lambda_arn_prefix_b%g" >> $helper_sed
fi

echo

############################################################
#
# Prompts
#

echo Checking Prompts ...
jq -r ".Id + \" \" + .Name" "$instance_alias_dir_a/prompts.json" |
tr -d '\r' |
while read prompt_id_a prompt_name; do
    prompt_name_encoded=$(path_encode "$prompt_name")
    # prompt_id_b=$(jq -r "select(.Name == \"${prompt_name//\"/\\\"}\") | .Id" "$instance_alias_dir_b/prompts.json")
    prompt_id_b=$(sed -e's/\\"/%22/g' "$instance_alias_dir_b/prompts.json" | jq -r "select(.Name == \"${prompt_name//\"/%22}\") | .Id")
    if [ -z "$prompt_id_b" ]; then
        echo "prompt_$prompt_name" >> $helper_new
    else
        echo "prompt_$prompt_name" >> $helper_old
        cat <<EOD >> $helper_sed
# Prompt: $prompt_name
s%$prompt_id_a%$prompt_id_b%g
EOD
    fi
done
test $? -eq 0 || error


############################################################
#
# Hours of operations
#

echo Checking Hours of operation ...
restype="Hours"
resource="hour_"
resfile="hours.json"
eval_resources "$restype" "$resource" "$resfile" "none" "none"


############################################################
#
# Queues
#

echo Checking Queues ...
restype="Queues"
resource="queue_"
resfile="queues.json"
queue_qc="queue_qc_"
eval_resources "$restype" "$resource" "$resfile" "none" "$queue_qc"


############################################################
#
# Routing Profiles
#

echo Checking Routing Profiles ...
restype="RP"
resource="routing_"
resfile="routings.json"
routingQs="routingQs_"
eval_resources "$restype" "$resource" "$resfile" "$routing_profile_to_ignore" "$routingQs"

############################################################
#
# Contact Flow Modules
#

echo Checking Contact Flow Modules ...
restype="FlowModule"
resource="module_"
resfile="modules.json"
eval_resources "$restype" "$resource" "$resfile" "none" "none"

############################################################
#
# Contact Flows
#
echo Checking Contact Flows ...
restype="CF"
resource="flow_"
resfile="flows.json"
eval_resources "$restype" "$resource" "$resfile" "none" "none"

cat > $flow_template <<EOD
{
    "Version": "2019-10-30",
    "StartAction": "e093fb75-2263-4594-875e-2d8e9974595f",
    "Metadata": {
        "entryPointPosition": {
            "x": 20,
            "y": 20
        },
        "snapToGrid": false,
        "ActionMetadata": {
            "e093fb75-2263-4594-875e-2d8e9974595f": {
                "position": {
                    "x": 223,
                    "y": 76
                }
            }
        }
    },
    "Actions": [
        {
            "Identifier": "e093fb75-2263-4594-875e-2d8e9974595f",
            "Type": "DisconnectParticipant",
            "Parameters": {},
            "Transitions": {}
        }
    ]
}
EOD


############################################################
#
# Quick Connects
#

echo Checking Quick Connects ...
restype="QuickConnects"
resource="quickconnect_"
resfile="quickconnects.json"
eval_resources "$restype" "$resource" "$resfile" "none" "none"


########################################
cat <<EOD

These helper files are created:
$helper_var: About the source and target Amazon Connect instances
$helper_new: Components to add to "$instance_alias_dir_b"
$helper_old: Components to update for "$instance_alias_dir_b" based on "$instance_alias_dir_a"
$helper_sed: SED script used to update components
$flow_template: Contact Flow template json

All done
EOD
